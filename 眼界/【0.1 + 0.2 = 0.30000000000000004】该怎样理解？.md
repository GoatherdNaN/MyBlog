如果你以前没了解过类似的坑，乍一看似乎觉得不可思议。但是某些语言下事实确实如此（比如 Javascript）：
![image](http://images2015.cnblogs.com/blog/675542/201512/675542-20151209204842621-242194588.png)

再看个例子，+1 后居然等于原数，没天理啊！  
![image](http://images2015.cnblogs.com/blog/675542/201512/675542-20151209204851933-2082526268.png)  
事实上不仅仅是 Javascript，在很多语言中 0.1 + 0.2 都会得到 0.30000000000000004，为此还诞生了一个好玩的网站 0.30000000000000004。究其根本，这些语言中的数字都是以 **IEEE 754 双精度 64 位浮点数** 来存储的，它的表示格式为：
> (s) * (m) * (2^e)  

s 是符号位，表示正负。m 是尾数，有 52 bits。e 是指数，有 11 bits，e 的范围是 [-1074, 971]（ECMAScript 5 规范），这样其实很容易推出 Javascript 能表示的最大数为：
> (Math.pow(2, 53) - 1) * Math.pow(2, 971) = 1.7976931348623157e+308
而这个数也就是 Number.MAX_VALUE 的值。

同理可推得 Number.MIN_VALUE 的值：
>  Math.pow(2, -1074) = 5e-324

[查看原文](http://www.cnblogs.com/zichi/p/5034201.html)